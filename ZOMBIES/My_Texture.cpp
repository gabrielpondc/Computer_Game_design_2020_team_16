

#include "stdafx.h"
#include"My_Texture.h"
//文字
//tga格式
bool Texture::LoadTGA(TextureImage *texture, char *filename)			// Loads A TGA File Into Memory
{
	GLubyte		TGAheader[12] = { 0,0,2,0,0,0,0,0,0,0,0,0 };	// Uncompressed TGA Header
	GLubyte		TGAcompare[12];								// Used To Compare TGA Header
	GLubyte		header[6];									// First 6 Useful Bytes From The Header
	GLuint		bytesPerPixel;								// Holds Number Of Bytes Per Pixel Used In The TGA File
	GLuint		imageSize;									// Used To Store The Image Size When Setting Aside Ram
	GLuint		temp;										// Temporary Variable
	GLuint		type = GL_RGBA;								// Set The Default GL Mode To RBGA (32 BPP)
	FILE *file;
	fopen_s(&file, filename, "rb");						// Open The TGA File
	if (file == NULL ||										// Does File Even Exist?
		fread(TGAcompare, 1, sizeof(TGAcompare), file) != sizeof(TGAcompare) ||	// Are There 12 Bytes To Read?
		memcmp(TGAheader, TGAcompare, sizeof(TGAheader)) != 0 ||	// Does The Header Match What We Want?
		fread(header, 1, sizeof(header), file) != sizeof(header))				// If So Read Next 6 Header Bytes
	{
		if (file == NULL)									// Did The File Even Exist? *Added Jim Strong*
			return false;									// Return False
		else
		{
			fclose(file);									// If Anything Failed, Close The File
			return false;									// Return False
		}
	}
	texture->width = header[1] * 256 + header[0];			// Determine The TGA Width	(highbyte*256+lowbyte)
	texture->height = header[3] * 256 + header[2];			// Determine The TGA Height	(highbyte*256+lowbyte)

															//OpenGL中纹理只能使用24位或者32位的TGA图像
	if (texture->width <= 0 ||								// Is The Width Less Than Or Equal To Zero
		texture->height <= 0 ||								// Is The Height Less Than Or Equal To Zero
		(header[4] != 24 && header[4] != 32))					// Is The TGA 24 or 32 Bit?
	{
		fclose(file);										// If Anything Failed, Close The File
		return false;										// Return False
	}
	texture->bpp = header[4];							// Grab The TGA's Bits Per Pixel (24 or 32)
	bytesPerPixel = texture->bpp / 8;						// Divide By 8 To Get The Bytes Per Pixel
	imageSize = texture->width*texture->height*bytesPerPixel;	// Calculate The Memory Required For The TGA Data

	texture->imageData = (GLubyte *)malloc(imageSize);		// Reserve Memory To Hold The TGA Data

	if (texture->imageData == NULL ||							// Does The Storage Memory Exist?
		fread(texture->imageData, 1, imageSize, file) != imageSize)	// Does The Image Size Match The Memory Reserved?
	{
		if (texture->imageData != NULL)						// Was Image Data Loaded
			free(texture->imageData);						// If So, Release The Image Data

		fclose(file);										// Close The File
		return false;										// Return False
	}
	//RGB数据格式转换，便于在OpenGL中使用
	for (GLuint i = 0; i<int(imageSize); i += bytesPerPixel)		// Loop Through The Image Data
	{														// Swaps The 1st And 3rd Bytes ('R'ed and 'B'lue)
		temp = texture->imageData[i];							// Temporarily Store The Value At Image Data 'i'
		texture->imageData[i] = texture->imageData[i + 2];	// Set The 1st Byte To The Value Of The 3rd Byte
		texture->imageData[i + 2] = temp;					// Set The 3rd Byte To The Value In 'temp' (1st Byte Value)
	}

	fclose(file);											// Close The File
															// Build A Texture From The Data
	glGenTextures(1, &texture[0].texID);					// Generate OpenGL texture IDs
	glBindTexture(GL_TEXTURE_2D, texture[0].texID);			// Bind Our Texture
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);	// Linear Filtered
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);	// Linear Filtered
	if (texture[0].bpp == 24)									// Was The TGA 24 Bits
	{
		type = GL_RGB;										// If So Set The 'type' To GL_RGB
	}
	glTexImage2D(GL_TEXTURE_2D, 0, type, texture[0].width, texture[0].height, 0, type, GL_UNSIGNED_BYTE, texture[0].imageData);
	return true;											// Texture Building Went Ok, Return True
}
//bmp格式
bool Texture::LoadT8(GLuint &texture, LPCWSTR filename)
{
	AUX_RGBImageRec *pImage = NULL;
	pImage = auxDIBImageLoad(filename);
	if (pImage == NULL)		return false;
	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);
	gluBuild2DMipmaps(GL_TEXTURE_2D, 4, pImage->sizeX,
		pImage->sizeY, GL_RGB, GL_UNSIGNED_BYTE, pImage->data);
	free(pImage->data);
	free(pImage);
	return true;
}

#define GL_CLAMP_TO_EDGE	0x812F
/***********************************************/
bool Texture::BuildTexture(char *filename, GLuint &texid)					// 载入一个.TGA 文件到内存
{

	GLubyte		TGAheader[12] = { 0,0,2,0,0,0,0,0,0,0,0,0 };				// 没有压缩的TGA Header
	GLubyte		TGAcompare[12];											// 用来比较 TGA Header
	GLubyte		header[6];												// Header里，头六个有用字节
	GLuint		bytesPerPixel;											// 保存TGA文件里每个像素用到的字节数
	GLuint		imageSize;												// 用来保存随机产生的图像的大小
	GLuint		temp;													// 临时变量
	GLuint		type = GL_RGBA;											// 将默认的GL模式设置为RBGA (32 BPP)
	GLubyte	*imageData;											// 图像数据 (最高32bit)
	GLuint	bpp;												// 每一象素的图像颜色深度
	GLuint	width;												// 图像宽度
	GLuint	height;												// 图像高度


	HDC			hdcTemp=0;												// DC用来保存位图
	HBITMAP		hbmpTemp=0;												// 保存临时位图
	IPicture	*pPicture;												// 定义IPicture Interface
	OLECHAR		wszPath[MAX_PATH + 1];									// 图片的完全路径
	char		szPath[MAX_PATH + 1];										// 图片的完全路径
	long		lWidth;													// 图像宽度
	long		lHeight;												// 图像高度
	long		lWidthPixels;											// 图像的宽带(以像素为单位)
	long		lHeightPixels;											// 图像的高带(以像素为单位)
	GLint		glMaxTexDim;											// 保存纹理的最大尺寸



	if (strstr(filename, "JPG") || strstr(filename, "bmp") || strstr(filename, "jpg") || strstr(filename, "BMP"))
	{


		if (strstr(filename, "http://"))									// 如果路径包含 http:// 则...
		{
			strcpy(szPath, filename);										// 把路径拷贝到 szPath
		}
		else																// 否则从文件导入图片
		{
			GetCurrentDirectoryA(MAX_PATH, szPath);							// 取得当前路径
			strcat(szPath, "\\");											// 添加字符"\"
			strcat(szPath, filename);										// 添加图片的相对路径
		}

		MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);		// 把ASCII码转化为Unicode标准码
		HRESULT hr = OleLoadPicturePath(wszPath, 0, 0, 0, IID_IPicture, (void**)&pPicture);

		if (FAILED(hr))														// 如果导入失败
		{
			// 图片载入失败出错信息
			MessageBoxA(HWND_DESKTOP, "TextureLoad Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);
			return FALSE;													// 返回 FALSE
		}

		hdcTemp = CreateCompatibleDC(GetDC(0));								// 建立窗口设备描述表
		if (!hdcTemp)														// 建立失败?
		{
			pPicture->Release();											// 释放IPicture
																			// 图片载入失败出错信息
			MessageBoxA(HWND_DESKTOP, "TextureLoad Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);
			return FALSE;													// 返回 FALSE
		}

		glGetIntegerv(GL_MAX_TEXTURE_SIZE, &glMaxTexDim);					// 取得支持的纹理最大尺寸

		pPicture->get_Width(&lWidth);										// 取得IPicture 宽度 (转换为Pixels格式)
		lWidthPixels = MulDiv(lWidth, GetDeviceCaps(hdcTemp, LOGPIXELSX), 2540);
		pPicture->get_Height(&lHeight);										// 取得IPicture 高度 (转换为Pixels格式)
		lHeightPixels = MulDiv(lHeight, GetDeviceCaps(hdcTemp, LOGPIXELSY), 2540);

		// 调整图片到最好的效果
		if (lWidthPixels <= glMaxTexDim)									// 图片宽度是否超过显卡最大支持尺寸
			lWidthPixels = 1 << (int)floor((log((double)lWidthPixels) / log(2.0f)) + 0.5f);
		else																// 否则,将图片宽度设为显卡最大支持尺寸
			lWidthPixels = glMaxTexDim;

		if (lHeightPixels <= glMaxTexDim)									// 图片高度是否超过显卡最大支持尺寸
			lHeightPixels = 1 << (int)floor((log((double)lHeightPixels) / log(2.0f)) + 0.5f);
		else																// 否则,将图片高度设为显卡最大支持尺寸
			lHeightPixels = glMaxTexDim;

		// 建立一个临时位图
		BITMAPINFO	bi = { 0 };												// 位图的类型
		DWORD		*pBits = 0;												// 指向位图Bits的指针

		bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);				// 设置结构大小
		bi.bmiHeader.biBitCount = 32;									// 32 位
		bi.bmiHeader.biWidth = lWidthPixels;							// 宽度像素值
		bi.bmiHeader.biHeight = lHeightPixels;						// 高度像素值
		bi.bmiHeader.biCompression = BI_RGB;								// RGB 格式
		bi.bmiHeader.biPlanes = 1;									// 一个位平面

																	// 建立一个位图这样我们可以指定颜色和深度 并访问每位的值
		hbmpTemp = CreateDIBSection(hdcTemp, &bi, DIB_RGB_COLORS, (void**)&pBits, 0, 0);

		if (!hbmpTemp)														// 建立失败?
		{
			DeleteDC(hdcTemp);												// 删除设备描述表
			pPicture->Release();											// 释放IPicture
																			// 图片载入失败出错信息
			MessageBoxA(HWND_DESKTOP, "TextureLoad Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);
			return FALSE;													// 返回 FALSE
		}

		SelectObject(hdcTemp, hbmpTemp);									// 选择临时DC句柄和临时位图对象

																			// 在位图上绘制IPicture
		pPicture->Render(hdcTemp, 0, 0, lWidthPixels, lHeightPixels, 0, lHeight, lWidth, -lHeight, 0);

		// 将BGR转换为RGB　将ALPHA值设为255
		for (long i = 0; i < lWidthPixels * lHeightPixels; i++)				// 循环遍历所有的像素
		{
			BYTE* pPixel = (BYTE*)(&pBits[i]);							// 获取当前像素
			BYTE  temp = pPixel[0];									// 临时存储第一个颜色像素(蓝色)
			pPixel[0] = pPixel[2];									// 将红色值存到第一位
			pPixel[2] = temp;											// 将蓝色值存到第三位
			pPixel[3] = 255;											// ALPHA值设为255
		}
		glGenTextures(1, &texid);											// 创建纹理
																			// 使用来自位图数据生成 的典型纹理
		glBindTexture(GL_TEXTURE_2D, texid);		// 绑定纹理
													//	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);	// 线形滤波
													//	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);   // 线形滤波
													/*
													glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
													glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
													*/
													//  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
													//  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //缩小采用三线性滤波
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//放大采用线性滤波
																		 //   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST); 


																		 // glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
																		 // glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
																		 //  glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);
																		 // glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);



																		 // 生成纹理
																		 //glTexImage2D(GL_TEXTURE_2D, 0, 3, lWidthPixels, lHeightPixels, 0, GL_RGB, GL_UNSIGNED_BYTE, pBits);
																		 //	glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,lWidthPixels, lHeightPixels,0,GL_RGB,GL_UNSIGNED_BYTE,pBits);

		gluBuild2DMipmaps(GL_TEXTURE_2D, 3, lWidthPixels, lHeightPixels, GL_RGBA, GL_UNSIGNED_BYTE, pBits);

		DeleteObject(hbmpTemp);												// 删除对象
		DeleteDC(hdcTemp);													// 删除设备描述表

		pPicture->Release();												// 释放 IPicture


	}



	else if (strstr(filename, "TGA") || strstr(filename, "tga"))									// 如果路径包含 http:// 则...
	{

		//	GLuint	texID;												// 纹理ID
		FILE *file = fopen(filename, "rb");									// 打开 TGA 文件

		if (file == NULL)													// 文件是否已存在?
		{
			// 图片载入失败出错信息
			MessageBoxA(HWND_DESKTOP, "TextureLoad Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);
			return FALSE;													// 返回FALSE
		}

		if (fread(TGAcompare, 1, sizeof(TGAcompare), file) != sizeof(TGAcompare)// 是否有十二个字节可读?
			|| memcmp(TGAheader, TGAcompare, sizeof(TGAheader)) != 0			// header和我们想要的是否相符?
			|| fread(header, 1, sizeof(header), file) != sizeof(header))		// 如果是读下六个字节
		{
			fclose(file);													// 如果失败,关闭文件
																			// 图片载入失败出错信息
			MessageBoxA(HWND_DESKTOP, "TextureLoad Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);
			return FALSE;													// 返回FALSE
		}

		width = header[1] * 256 + header[0];						// 确定的TGA 宽度 (高字节*256+低字节)
		height = header[3] * 256 + header[2];						// 确定的TGA 高度 (高字节*256+低字节)

		if (width <= 0											// 宽度是否小于等于0
			|| height <= 0										// 高度是否小于等于0
			|| (header[4] != 24 && header[4] != 32))							// TGA 是24位或32位?
		{
			fclose(file);													// 任何一个不成立, 则关闭文件
																			// 图片载入失败出错信息
			MessageBoxA(HWND_DESKTOP, "TextureLoad Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);
			return FALSE;													// 返回FALSE
		}

		bpp = header[4];										// 获取TGA每个像素的位(24 or 32)
		bytesPerPixel = bpp / 8;									// 除以8以取得 每个像素的字节
		imageSize = width*height*bytesPerPixel;		// 计算TAG数据所需要的内存

		imageData = (GLubyte *)malloc(imageSize);					// 开辟一个内存空间用来存储TGA数据

		if (imageData == NULL 										// 用来存储的内存是否存在?
			|| fread(imageData, 1, imageSize, file) != imageSize)	// 图像大小是否和内存空间大小相符？
		{
			if (imageData != NULL)									// 图像数据是否载入
			{
				free(imageData);									// 如果是 释放图像数据
			}
			fclose(file);													// 关闭文件
			MessageBoxA(HWND_DESKTOP, "TextureLoad Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);
			return FALSE;													// 返回FALSE
		}

		for (GLuint i = 0; i<int(imageSize); i += bytesPerPixel)				// 循环遍历图像数据
		{																	// 交换第一和第三字节(红 和 蓝)
			temp = imageData[i];										// 将图像数据‘i’的值存在临时变量中
			imageData[i] = imageData[i + 2];				// 将第三个字节的值存到第一个字节里
			imageData[i + 2] = temp;								// 将临时变量的值存入第三字节(第一字节的值)
		}

		fclose(file);														// 关闭文件

																			//创建一种纹理
		glGenTextures(1, &texid);									// 产生OpenGL纹理ID

		glBindTexture(GL_TEXTURE_2D, texid);						// 绑定纹理
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);	// 线性滤波
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);	// 线性滤波


		if (bpp == 24)												// TGA图片是不是 24 位的
		{
			type = GL_RGB;													// 如果是将'type'设置为 GL_RGB
		}

		glTexImage2D(GL_TEXTURE_2D, 0, type, width, height, 0, type, GL_UNSIGNED_BYTE, imageData);

		free(imageData);
	}


	DeleteObject(hbmpTemp);												// 删除对象
	DeleteDC(hdcTemp);													// 删除设备描述表
	return TRUE;														// 纹理创建成功，返回正确
}


int Texture::LoadGLTextures(char *Filename, GLuint *ttexture)//ttexture[i]为用来绑定纹理数据的整数,可更改
{
	FILE *File;
	BITMAPINFOHEADER header;
	BYTE *texture;//texture长宽和像素RGBA texture[width][height][4]
	int width, height, m, j;
	unsigned char *image;
	File = fopen(Filename, "rb");
	//读取BMP信息头，跳过14字节文件头
	if (File) {
		fseek(File, 14, SEEK_SET);
		fread(&header, sizeof(BITMAPINFOHEADER), 1, File);
	}
	else return FALSE;
	//读取长宽
	width = header.biWidth;
	height = header.biHeight;
	//为image分配像素空间，读取图片数据，为texture分配width*height*4的四位空间用来生成纹理
	image = (unsigned char *)malloc(width*height * 3);
	fread(image, sizeof(unsigned char), width*height * 3, File);//唯一的不足之处在于将3字节像素读为一维字符串
	texture = (BYTE *)malloc(width*height * 4);// 唯一的不足之处在于将4字节像素读为一维字符串
											   //以下代码将对texture重排列，一般来说为Blue Green Red Alpha格式(24位图格式),生成纹理使用BGRA模式
											   /****************************************修改模块,通过像素任意修改图片，示例:*************************************************************/
											   //本段代码将纯黑色像素点透明度(Alpha)设为100%,其余颜色设为0%
	for (m = 0; m < width; m++)
	{
		for (j = 0; j < height; j++)
		{
			//把颜色值写入 
			texture[m*width * 4 + j * 4] = image[m*width * 3 + j * 3];
			texture[m*width * 4 + j * 4 + 1] = image[m*width * 3 + j * 3 + 1];
			texture[m*width * 4 + j * 4 + 2] = image[m*width * 3 + j * 3 + 2];
			//设置alpha值,假设黑色为透明色 
			if (texture[m*width * 4 + j * 4] == 0 && texture[m*width * 4 + j * 4 + 1] == 0 && texture[m*width * 4 + j * 4 + 2] == 0)
				texture[m*width * 4 + j * 4 + 3] = 0;                 //透明，alpha=0 
			else
				texture[m*width * 4 + j * 4 + 3] = 255;           //不透明，alpha=255
		}
	}
	//ttexture[i]为绑定纹理的整数
	//下面生成纹理以及纹理处理
	glGenTextures(1, ttexture);
	glBindTexture(GL_TEXTURE_2D, *ttexture);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexImage2D(GL_TEXTURE_2D, 0, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture);
	gluBuild2DMipmaps(GL_TEXTURE_2D, 4, width, height, GL_BGRA, GL_UNSIGNED_BYTE, texture);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glAlphaFunc(GL_GREATER, 0.5);//使Alpha值生效
								 //纹理生成完毕,下面释放空间
	free(texture);
	free(image);						// 释放图像数据
	return TRUE;
}